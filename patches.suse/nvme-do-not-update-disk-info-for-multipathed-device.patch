From ac55ebb15df8fab1b30b8bfda2c0f463a162db08 Mon Sep 17 00:00:00 2001
From: Hannes Reinecke <hare@suse.de>
Date: Tue, 15 Sep 2020 11:49:00 +0200
Subject: [PATCH] nvme: do not update disk info for multipathed device
References: bsc#1171558
Patch-mainline: No, handled differently upstream

For a multipathed disk it's actually wrong to update the device
parameter when a path comes back; there is a good chance that the
multipath device will have other paths, and updating the device
characteristics has the potential of corrupting/invalidating the
other paths.
A real fix would be to compare the parameters, and reject this path
if they differ. In the absence of such a check just don't update
the disk characteristics for the multipath device.

Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/nvme/host/core.c |    9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -1557,7 +1557,8 @@ static void nvme_update_disk_info(struct
 	blk_mq_unfreeze_queue(disk->queue);
 }
 
-static void __nvme_revalidate_disk(struct gendisk *disk, struct nvme_id_ns *id)
+static void __nvme_revalidate_disk(struct gendisk *disk, struct nvme_id_ns *id,
+				   bool first_scan)
 {
 	struct nvme_ns *ns = disk->private_data;
 
@@ -1583,7 +1584,7 @@ static void __nvme_revalidate_disk(struc
 	if (ns->ndev)
 		nvme_nvm_update_nvm_info(ns);
 #ifdef CONFIG_NVME_MULTIPATH
-	if (ns->head->disk && ns->ctrl->state == NVME_CTRL_LIVE) {
+	if (ns->head->disk && ns->ctrl->state == NVME_CTRL_LIVE && first_scan) {
 		nvme_update_disk_info(ns->head->disk, ns, id);
 		blk_queue_stack_limits(ns->head->disk->queue, ns->queue);
 		nvme_mpath_update_disk_size(ns->head->disk);
@@ -1616,7 +1617,7 @@ static int nvme_revalidate_disk(struct g
 		goto free_id;
 	}
 
-	__nvme_revalidate_disk(disk, id);
+	__nvme_revalidate_disk(disk, id, false);
 	ret = nvme_report_ns_ids(ctrl, ns->head->ns_id, id, &ids);
 	if (ret)
 		goto free_id;
@@ -3229,7 +3230,7 @@ static int nvme_alloc_ns(struct nvme_ctr
 	memcpy(disk->disk_name, disk_name, DISK_NAME_LEN);
 	ns->disk = disk;
 
-	__nvme_revalidate_disk(disk, id);
+	__nvme_revalidate_disk(disk, id, true);
 
 	down_write(&ctrl->namespaces_rwsem);
 	list_add_tail(&ns->list, &ctrl->namespaces);
